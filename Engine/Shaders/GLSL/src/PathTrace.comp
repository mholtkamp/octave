#version 450

#extension GL_ARB_separate_shader_objects : enable

#include "Common.glsl"
#include "PathTraceCommon.glsl"

layout (set = 0, binding = 0) uniform GlobalUniformBuffer 
{
    GlobalUniforms global;
};

layout (set = 1, binding = 0) uniform PathTraceUniformBuffer 
{
	PathTraceUniforms pathTrace;
};

layout(std140, set = 1, binding = 1) buffer TriangleData  
{
   PathTraceTriangle triangles[];
};

layout(std140, set = 1, binding = 2) buffer MeshData  
{
   PathTraceMesh meshes[];
};

layout(std140, set = 1, binding = 3) buffer LightData  
{
   PathTraceLight lights[];
};

layout (set = 1, binding = 4, rgba8) uniform image2D outputImage;

layout (local_size_x = 8, local_size_y = 8) in;

HitInfo CalculateRayCollision(Ray ray)
{
    // Trace bounding spheres of all meshes
    HitInfo closestHit = CreateHitInfo();
    closestHit.mDistance = 1e20;
    closestHit.mMaterial.mColor = vec4(0,0,0,1);

    for (uint i = 0; i < pathTrace.mNumMeshes; ++i)
    {
        PathTraceMesh mesh = meshes[i];
        HitInfo boundsHit = RaySphereTest(ray, mesh.mBounds.xyz, mesh.mBounds.w);

        if (boundsHit.mHit && boundsHit.mDistance < closestHit.mDistance)
        {
            closestHit = boundsHit;
            closestHit.mMaterial = mesh.mMaterial;
        }
    }

    return closestHit;
} 

vec3 PathTrace(Ray ray, inout uint rngState)
{
    vec3 incomingLight = vec3(0,0,0);
    vec3 rayColor = vec3(1,1,1);

    for (uint i = 0; i < pathTrace.mMaxBounces; ++i)
    {
        HitInfo hitInfo = CalculateRayCollision(ray);
        if (hitInfo.mHit)
        {
            ray.mOrigin = hitInfo.mPosition;
            ray.mDirection = RandomHemisphereDirection(hitInfo.mNormal, rngState);

            MaterialUniforms material = hitInfo.mMaterial;
            bool emit = (material.mShadingModel == SHADING_MODEL_UNLIT);
            vec3 emittedLight = emit ? material.mColor.rgb : vec3(0, 0, 0);
            incomingLight += (emittedLight * rayColor);
            rayColor *= (emit ? vec3(1,1,1) : material.mColor.rgb);
        }
        else
        {
            break;
        }
    }

    return incomingLight;
}

void main()
{
    uint threadIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(global.mScreenDimensions.x + 0.5) + global.mFrameNumber * 719393;
    uint rngState = threadIndex;

    vec2 uv = gl_GlobalInvocationID.xy / global.mScreenDimensions;

    vec3 viewPointVS = vec3(2.0 * (uv - 0.5) * vec2(global.mNearHalfWidth, -global.mNearHalfHeight), -global.mNearDist);
    vec3 viewPoint = (global.mViewToWorld * vec4(viewPointVS, 1.0)).xyz;

    Ray ray;
    ray.mOrigin = global.mViewPosition.xyz;
    ray.mDirection = normalize(viewPoint - ray.mOrigin);

    vec3 totalLight = vec3(0,0,0);
    uint numRays = pathTrace.mRaysPerPixel;

    for (uint i = 0; i < numRays; ++i)
    {
        totalLight += PathTrace(ray, rngState);
    }

    vec3 newColor = totalLight / numRays;
    vec3 oldColor = imageLoad(outputImage, ivec2(gl_GlobalInvocationID.xy)).rgb;

    float newWeight = 1.0 / (pathTrace.mAccumulatedFrames + 1);
    vec3 outColor = mix(oldColor, newColor, newWeight);

    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(outColor,1));
}
