#version 450

#extension GL_ARB_separate_shader_objects : enable

#include "Common.glsl"
#include "PathTraceCommon.glsl"

layout (set = 0, binding = 0) uniform GlobalUniformBuffer 
{
    GlobalUniforms global;
};

layout(std140, set = 1, binding = 0) buffer TriangleData  
{
   PathTraceTriangle triangles[];
};

layout(std140, set = 1, binding = 1) buffer MeshData  
{
   PathTraceMesh meshes[];
};

layout(std140, set = 1, binding = 2) buffer LightData  
{
   PathTraceLight lights[];
};

layout (set = 1, binding = 3, rgba8) uniform image2D outputImage;

layout (local_size_x = 8, local_size_y = 8) in;

void main()
{
    vec2 uv = gl_GlobalInvocationID.xy / global.mScreenDimensions;

    vec3 viewPointVS = vec3(2.0 * (uv - 0.5) * vec2(global.mNearHalfWidth, -global.mNearHalfHeight), -global.mNearDist);
    vec3 viewPoint = (global.mViewToWorld * vec4(viewPointVS, 1.0)).xyz;

    Ray ray;
    ray.mOrigin = global.mViewPosition.xyz;
    ray.mDirection = normalize(viewPoint - ray.mOrigin);

    // Test sphere
#if 1
    float t = global.mRealElapsedTime;
    float speed = 3.0;
    vec3 sphereCenter = vec3(cos(t * speed), sin(t * speed), 1.0);
    float sphereRadius = 1.0 + 0.3 * cos(t);
#else
    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);
    float sphereRadius = 1.0;
#endif

    HitInfo hitInfo = RaySphereTest(ray, sphereCenter, sphereRadius);

    vec4 outColor = vec4(0,0,0,1);
    if (hitInfo.mHit)
    {
        outColor = vec4(hitInfo.mNormal, 1.0);
    }

	imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), outColor);
}
